#! /usr/bin/env bash

# ===========================================================================
#
# Copyright (c) 2017-2020 Unvanquished Developers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# ===========================================================================

shell_options=(-u -e -o pipefail)
set "${shell_options[@]}"

throwError () {
	local error_keyword="${1}"
	local error_message="${2}"
	local error_code

	case "${error_keyword}" in
		'BADREQUEST')
			error_code=2
			;;
		'INTERNAL')
			error_code=3
			;;
		'NOTIMPLEMENTED')
			error_code=4
			;;
	esac

	printf 'ERROR %s: %s\n' "${error_keyword}" "${error_message}" >&2
	exit "${error_code}"
}

printWarning() {
	printf 'WARNING: %s\n' "${1}" >&2
}

printHelp () {
	local prog_name="$(basename "${0}")"
	local tab="$(printf '\t')"

	cat <<-EOF
	${prog_name}: a tool to build game for release purpose.

	Usage:

	${tab}${prog_name} [option] <target>

	The script must be called within game source directory,
	but can be called from anywhere in source directory.

	Option can be:

	${tab}-j<NUMBER>
	${tab}${tab}with NUMBER the number of parallel compilation jobs

	${tab}-p
	${tab}${tab}build multiple targets at once in parallel
	${tab}${tab}beware: return code will be inaccurate

	${tab}-u
	${tab}${tab}write username in version string (requires -v)

	${tab}-v
	${tab}${tab}write package version strings

	${tab}--fake-urcheon
	${tab}${tab}Badly emulate Urcheon, useful when Urcheon isn't available.
	${tab}${tab}File optimizations and delta pak building with --reference
	${tab}${tab}are missing.

	${tab}-r [reference]
	${tab}--reference [reference]
	${tab}${tab}Build a delta base dpk from this reference, requires Urcheon.

	${tab}--vmpak-name [name]
	${tab}${tab}Use this name as vm dpk base name.

	${tab}--basepak-name [name]
	${tab}${tab}Use this name as base dpk base name, also used for the mod pak.

	Target can be:

	${tab}vm
	${tab}${tab}Build a dpk with the game code virtual machine.

	${tab}base
	${tab}${tab}Build the base dpk.

	${tab}mod
	${tab}${tab}Build the base dpk with game code virtual machine.

	${tab}linux-i686
	${tab}${tab}build linux x86 engine

	${tab}linux-amd64
	${tab}${tab}build linux x86_64 engine

	${tab}macos-amd64
	${tab}${tab}build mac x86_64 engine

	${tab}windows-i686
	${tab}${tab}build windows x86 engine

	${tab}windows-amd64
	${tab}${tab}build windows x86_64 engine

	Example:

	${tab}${prog_name} vm linux-amd64

	EOF

	exit
}

getUserName () {
	whoami \
	| tr '[:upper:]' '[:lower:]' \
	| tr -d '[:blank:]' \
	| tr -d '[:punct:]' \
	| cut -c'1-10'
}

getBinPath () {
	local system_windows="${1}"
	local bin_name="${2}"

	if "${system_windows}"
	then
		echo "${bin_name}.exe"
	else
		echo "${bin_name}"
	fi
}

dumpSymbols () {
	local dumpsyms_bin="${1}"
	local symbol_dir="${2}"
	local exec_file="${3}"

	local temp_file="$(mktemp)"

	"${dumpsyms_bin}" "${exec_file}" > "${temp_file}"

	local symbol_basename="$(head -n'1' "${temp_file}" | cut -f'5' -d' ')"

	local build_id="$(head -n'1' "${temp_file}" | cut -f'4' -d' ')"

	local exec_symbol_dir="${symbol_dir}/${symbol_basename}/${build_id}"

	mkdir -pv "${exec_symbol_dir}"

	mv "${temp_file}" "${exec_symbol_dir}/${symbol_basename}.sym"
}

findDll () {
	local mingw_arch="${1}"
	local dll_name="${2}"

	if [ -z "${mingw_arch}" ]
	then
		find "${MINGW_PREFIX}/bin/${dll_name}"
		return
	fi

	# HACK: sort to get posix flavor of libstdc++ before win32 flavor
	find '/usr' -name "${dll_name}" -type f | sort | grep --max-count=1 "${mingw_arch}" \
	|| throwError INTERNAL "couldn't find DLL ${dll_name}"
}

cleanSymbols () {
	local symbol_dir="${1}"
	local symbol_archive_filename="${2}"

	if [ -e "${symbol_dir}" ]
	then
		find "${symbol_dir}" -type f -name '*.sym' -exec rm -v {} \;
		find "${symbol_dir}" -depth -type d -exec rmdir {} \;
	fi

	if [ -f "${symbol_archive_filename}" ]
	then
		rm "${symbol_archive_filename}"
	fi
}

cleanBinaries () {
	local system_windows="${1}"
	local target_build_dir="${2}"
	local content_dir="${3}"
	local bin_list="${4}"

	for bin_filename in ${bin_list}
	do
		bin_path="$(getBinPath "${system_windows}" "${target_build_dir}/${bin_filename}")"
		engine_bin_path="$(getBinPath "${system_windows}" "${content_dir}/${bin_filename}")"
		if [ -f "${bin_path}" ]
		then
			rm "${bin_path}"
		fi

		if [ -f "${engine_bin_path}" ]
		then
			rm "${engine_bin_path}"
		fi
	done

	if [ -d "${content_dir}" ]
	then
		rmdir "${content_dir}"
	fi
}

cleanEngineBuildDir () {
	local content_dir="${1}"

	if [ -e "${content_dir}" ]
	then
		find "${content_dir}" -type f -exec rm -v {} \;
		find "${content_dir}" -depth -type d -exec rmdir {} \;
	fi
}

cleanVmBuildDir () {
	local content_dir="${1}"
	local symbol_archive_basename="${2}"

	if [ -e "${content_dir}" ]
	then
		find "${content_dir}" -type f -name '?game-*.nexe' -exec rm -v {} \;
		find "${content_dir}" -type f -name "${symbol_archive_basename}.*" -exec rm -v {} \;
		find "${content_dir}" -depth -type d -exec rmdir {} \;
	fi
}

package () {
	local extend_archive='false'
	if [ "${1}" = '--extend' ]
	then
		extend_archive='true'
		shift
	fi

	local archive_format="${1}"
	local archive_filename="${2}"
	local content_dir="${3}"

	(
		cd "${content_dir}"

		if ! "${extend_archive}"
		then
		if [ -f "${archive_filename}" ]
		then
				rm "${archive_filename}"
			fi
		fi

		7z -mx='9' -t"${archive_format}" a "${archive_filename}" .
	)
}

printVersion () {
	local tag_string='0'
	local date_string=''
	local ref_string=''
	local dirt_string=''

	local git_last_commit_short="$(git rev-parse --short HEAD)"

	if [ -n "${git_last_commit_short}" ]
	then
		local git_describe_string="$(git describe --tags --match 'v[0-9].*' 2>/dev/null | cut -c2-)"
		local git_closest_tag="$(git describe --tags --abbrev=0 --match 'v[0-9].*' 2>/dev/null | cut -c2-)"
		local git_last_commit_date="$(date --date="@$(git log -1 '--pretty=format:%ct')" --utc '+%Y%m%d-%H%M%S')"

		if [ -n "${git_closest_tag}" ]
		then
			tag_string="${git_closest_tag}"

			if [ "${git_closest_tag}" != "${git_describe_string}" ]
			then
				date_string="-${git_last_commit_date}"
				ref_string="-${git_last_commit_short}"
			fi
		else
			date_string="-${git_last_commit_date}"
			ref_string="-${git_last_commit_short}"
		fi
	else
		date_string="-$(date --utc '+%Y%m%d-%H%M%S')"
		ref_string='-0'
	fi

	if ! git diff --quiet 2>/dev/null
	then
		dirt_string='-dirty'
	fi

	echo "${tag_string}${date_string}${ref_string}${dirt_string}"
}

fakeUrcheonBuildFile () {
	# It is assumed the file path is relative to the current directory
	# and stored in the current directory.
	local file_path="${1}"
	local destination_dir="${2}"
	local dir_name="$(dirname "${file_path}")"

	mkdir -p "${destination_dir}/${dir_name}"
	cp -a "${file_path}" "${destination_dir}/${file_path}"
}

export -f fakeUrcheonBuildFile

fakeUrcheon () {
	printWarning 'Badly emulating Urcheon.'

	local target_build_dir="${1}"
	local archive_filename="${2}"
	local content_dir="${3}"

	(
		cd "${content_dir}"

		declare -a filter_options

		printWarning 'Badly emulating Urcheon pakignore processing.'
		# HACK: File extensions known to be ignored
		# from unvanquished_src.dpkdir on 2022-09-10.
		printWarning 'Badly emulating Urcheon known dirt file processing.'
		local ignore_filter="$(mktemp)"
		cat > "${ignore_filter}" <<-EOF
		# Some Urcheon ignored files from per-game file profile.
		*.xcf
		*.xcf.*
		*.svg
		# Some Urcheon ignored files from known dirt files.
		Thumbs.db
		__MACOSX
		*.DS_Store
		.*.swp
		*~
		EOF

		exclude_options=(--exclude-from="${ignore_filter}")

		# HACK: This may not be the same algorithm as git.
		if [ -f '.pakignore' ]
		then
			printWarning 'Badly emulating Urcheon pakignore processing.'
			exclude_options+=(--exclude-from='.pakignore')
		fi

		# HACK: It assumes all deleted files are from the current package.
		local deleted_file='false'
		if [ -f 'DELETED' ]
		then
			printWarning 'Badly emulating Urcheon DELETED processing.'
			deleted_file='true'
			
			local ignore_deleted="$(mktemp)"
			awk '{print $2}' < 'DELETED' > "${ignore_deleted}"
			exclude_options+=(--exclude-from="${ignore_deleted}")
		fi

		mkdir -p "${target_build_dir}"

		printWarning 'Badly emulating Urcheon file building.'
		# HACK: files are copied without any check for compatibility
		# neither any format conversion.
		git ls-files "${exclude_options[@]}" -cmo \
		| grep -E -v '\.gitignore$|^\.pakinfo' \
		| sort \
		| xargs -r -I{} -P1 \
			/usr/bin/env bash "${shell_options[@]}" \
				-c "fakeUrcheonBuildFile {} ${target_build_dir} || exit 255" fakeUrcheonBuildFile

		printWarning 'Badly emulating Urcheon file packaging.'
		package 'zip' "${archive_filename}" "${target_build_dir}"

		rm "${ignore_filter}"
	)
}

runUrcheon () {
	local target_build_dir="${1}"
	local archive_filename="${2}"
	local content_dir="${3}"

	declare -a build_options

	if [ -n "${old_reference}" ]
	then
		build_options=(--reference "${old_reference}")
	fi

	urcheon \
		--test-dir "${target_build_dir}" \
		build \
		"${build_options[@]}" \
		"${content_dir}"

	urcheon \
		--test-dir "${target_build_dir}" \
		--pak-file "${archive_filename}" \
		package \
		"${content_dir}"
}

build () {
	local job_count="${1}"
	local write_version_string="${2}"
	local write_username_string="${3}"
	local root_dir="${4}"
	local target="${5}"

	local symbol_archive_basename='symbols'
	local vmpak_archive_basename=''
	local engine_archive_basename=''

	local engine_archive_format='zip'
	local symbol_archive_format='7z'
	local pak_archive_format='zip'
	local pak_archive_extension='dpk'

	local build_dir="${root_dir}/build"
	local release_dir="${build_dir}/release"

	local vm_kind_list='cgame sgame'
	local vm_arch_list='x86 x86_64'
	local main_nexe='main.nexe'

	local engine_file_list=''
	local engine_strip_list=''
	local engine_symbolize_list=''

	local build_vm='false'
	local build_base='false'
	local build_engine='false'

	local system_linux='false'
	local system_macos='false'
	local system_windows='false'
	local dumpsyms_relpath=''

	local arch_amd64='false'
	local arch_i686='false'

	local host_linux='false'
	local host_mac='false'
	local host_windows='false'

	local mingw_arch_prefix=''

	case "${target}" in
		'vm')
			build_vm='true'
			dumpsyms_relpath=linux/dump_syms/dump_syms
			;;
		'base')
			build_base='true'
			;;
		'mod')
			build_vm='true'
			build_base='true'
			dumpsyms_relpath=linux/dump_syms/dump_syms
			;;
		'linux-'*)
			build_engine='true'
			system_linux='true'
			dumpsyms_relpath=linux/dump_syms/dump_syms
			;;
		'macos-'*)
			build_engine='true'
			system_macos='true'
			dumpsyms_relpath=mac/dump_syms/dump_syms_mac
			;;
		'windows-'*)
			build_engine='true'
			system_windows='true'
			dumpsyms_relpath=windows/dump_syms_dwarf/dump_syms
			;;
	esac

	case "${target}" in
		*'-amd64')
			arch_amd64='true'
			engine_file_list="${engine_file_list} irt_core-x86_64.nexe"
			;;
		*'-i686')
			arch_i686='true'
			engine_file_list="${engine_file_list} irt_core-x86.nexe"
			;;
	esac

	local target_root_dir="${build_dir}/target"
	local target_build_dir="${target_root_dir}/${target/mod/vm}"
	local content_dir="${target_build_dir}/content"
	local symbol_dir="${target_build_dir}/${symbol_archive_basename}"
	local symbol_archive_filename="${target_build_dir}/${symbol_archive_basename}.${symbol_archive_format}"

	local uname_system="$(uname -s)"
	case "${uname_system}" in
		'Linux'*)
			host_linux='true'
			;;
		'Darwin'*)
			host_mac='true'
			;;
		'CYGWIN'*|'MINGW'*)
			host_windows='true'
			;;
		*)
			throwError NOTIMPLEMENTED "unknown system: ${uname_system}"
			;;
	esac

	if "${write_version_string}"
	then
		build_version="$(printVersion)"

		if "${write_username_string}"
		then
			build_version+="-$(whoami | tr '[:upper:]' '[:lower:]')"
		fi

		vmpak_version_string="_${build_version}"
		engine_version_string="_${build_version}"
	else
		vmpak_version_string='_0'
		engine_version_string=''
	fi

	if [ -z "${job_count}" ]
	then
		if command -v 'nproc' >/dev/null
		then
			job_count="$(nproc)"
		elif command -v 'sysctl' >/dev/null
		then
			job_count="$(sysctl -n 'hw.ncpu')"
		else
			job_count='4'
		fi
	fi

	if [ -d "${target_build_dir}" ]
	then
		echo "Removing '${target_build_dir}' and contents"
		# Safe w.r.t. symlinks, as long as you don't put a trailing slash:
		# https://superuser.com/questions/382314/does-rm-rf-follow-symbolic-links
		rm -r "${target_build_dir}"
	fi

	mkdir -pv "${target_build_dir}"
	mkdir -pv "${release_dir}"

	local cmake_opts='-DBUILD_GAME_NATIVE_DLL=OFF -DBUILD_GAME_NATIVE_EXE=OFF'
	local cmake_cflags=''

	produce_symbols='true'

	if "${system_macos}"
	then
		produce_symbols='false'
		PATH="${PATH}:/Applications/CMake.app/Contents/bin"
		cmake_opts="${cmake_opts} -DCMAKE_OSX_DEPLOYMENT_TARGET=10.9 -DCMAKE_BUILD_TYPE=Release -DUSE_BREAKPAD=OFF"
	else
		cmake_opts="${cmake_opts} -DCMAKE_BUILD_TYPE=RelWithDebInfo -DUSE_BREAKPAD=ON"
	fi

	if "${build_base}" && ! "${build_vm}"
	then
		produce_symbols='false'
	fi

	if "${system_macos}" && "${arch_amd64}"
	then
		cmake_opts="${cmake_opts} -DCMAKE_OSX_ARCHITECTURES=x86_64"
	fi

	if "${build_base}"
	then
		local dpk_dir="$(find "${root_dir}/pkg" -type d -name '*_src.dpkdir' -print -quit)"

		if [ -n "${basepak_name}" ]
		then
			basepak_archive_basename="${basepak_name}"
		else
			basepak_archive_basename="$(basename "${dpk_dir}" | cut -f1 -d'_')"
		fi
	fi

	if "${build_vm}"
	then
		if [ -n "${vmpak_name}" ]
		then
			vmpak_archive_basename="${vmpak_name}"
		else
		vmpak_archive_basename='vm'
		fi

		cmake_opts="${cmake_opts} -DBUILD_GAME_NACL=ON -DBUILD_GAME_NACL_NEXE=ON -DBUILD_CGAME=ON -DBUILD_SGAME=ON -DBUILD_CLIENT=OFF -DBUILD_TTY_CLIENT=OFF -DBUILD_SERVER=OFF"
	fi

	if "${build_engine}"
	then
		engine_archive_basename="${target}"
		cmake_opts="${cmake_opts} -DUSE_LTO=ON -DBUILD_CLIENT=ON -DBUILD_SERVER=ON -DBUILD_TTY_CLIENT=ON -DBUILD_GAME_NACL=OFF -DBUILD_GAME_NACL_NEXE=OFF -DBUILD_CGAME=OFF -DBUILD_SGAME=OFF -DUSE_HARDENING=1"

		local strip='strip'
		if "${system_windows}" && ! "${host_windows}"
		then
			if "${arch_i686}"
			then
				bitness='32'
				mingw_arch_prefix='i686'
			else
				bitness='64'
				mingw_arch_prefix='x86_64'
			fi

			strip="${mingw_arch_prefix}-w64-mingw32-strip"
			cmake_opts="${cmake_opts} -DCMAKE_TOOLCHAIN_FILE=${root_dir}/daemon/cmake/cross-toolchain-mingw${bitness}.cmake"
			# unused
			# cmake_opts="${cmake_opts} -DPKG_CONFIG_EXECUTABLE=${mingw_arch_prefix}-w64-mingw32-pkg-config"
		fi

		if ${system_linux}
		then
			cmake_opts="${cmake_opts} -DUSE_STATIC_LIBS=1 -DOpenGL_GL_PREFERENCE=LEGACY"
			engine_file_list="${engine_file_list} daemon daemonded daemon-tty crash_server nacl_helper_bootstrap nacl_loader"
			engine_symbolize_list='daemon daemonded daemon-tty'
			engine_strip_list='daemon daemonded daemon-tty crash_server'
			if "${arch_i686}"
			then
				cmake_opts="${cmake_opts} -DCMAKE_TOOLCHAIN_FILE=${root_dir}/daemon/cmake/cross-toolchain-linux32.cmake"
			fi
		fi

		if "${system_macos}"
		then
			engine_file_list="${engine_file_list} daemon daemonded daemon-tty nacl_loader"
			# No Breakpad, hence no symbolize and strip steps
		fi

		if "${system_windows}"
		then
			if "${arch_i686}"
			then
				engine_file_list="${engine_file_list} nacl_loader64.exe irt_core-x86_64.nexe" # WOW64 support

				if "${host_windows}"
				then
					# MSYS2 uses the DWARF exception flavor
					special_dll='libgcc_s_dw2-1.dll'
				else
					special_dll='libgcc_s_sjlj-1.dll'
				fi
			else
				special_dll='libgcc_s_seh-1.dll'
			fi

			extra_dll_list="${special_dll} libstdc++-6.dll libwinpthread-1.dll libssp-0.dll"
			# DLLs are added to engine_file_list after building
			engine_file_list="${engine_file_list} daemon.exe daemonded.exe daemon-tty.exe crash_server.exe nacl_loader.exe"
			engine_symbolize_list='daemon.exe daemonded.exe daemon-tty.exe'
			engine_strip_list='daemon.exe daemonded.exe daemon-tty.exe crash_server.exe'

			# those paths are distro-centric
			# cp -av "/usr/${mingw_arch_prefix}-w64-mingw32/lib/libwinpthread-1.dll" "${target_build_dir}/"
			# cp -av "/usr/lib/gcc/${mingw_arch_prefix}-w64-mingw32/7.3-posix/libstdc++-6.dll" "${target_build_dir}/"
			# cp -av "/usr/lib/gcc/${mingw_arch_prefix}-w64-mingw32/7.3-posix/${special_dll}" "${target_build_dir}/"
			for dll_name in ${extra_dll_list}
			do
				dll_location="$(findDll "${mingw_arch_prefix}" "${dll_name}")"
				cp -av "${dll_location}" "${target_build_dir}/"
			done
		fi

		local strip='strip'
		if "${system_windows}" && ! "${host_windows}"
		then
			if "${arch_i686}"
			then
				bitness='32'
				mingw_arch_prefix='i686'
			else
				bitness='64'
				mingw_arch_prefix='x86_64'
			fi

			strip="${mingw_arch_prefix}-w64-mingw32-strip"
			cmake_opts="${cmake_opts} -DCMAKE_TOOLCHAIN_FILE=${root_dir}/daemon/cmake/cross-toolchain-mingw${bitness}.cmake"
			# unused
			# cmake_opts="${cmake_opts} -DPKG_CONFIG_EXECUTABLE=${mingw_arch_prefix}-w64-mingw32-pkg-config"
		fi
	fi

	if "${build_vm}"
	then
		# configuration

		cmake -H"${root_dir}" \
			-B"${target_build_dir}" \
			-G"Unix Makefiles" \
			${cmake_opts} \
		|| throwError INTERNAL "${target} cmake failed"
	fi

	if "${build_engine}"
	then
		# configuration

		cmake -H"${root_dir}" \
			-B"${target_build_dir}" \
			-G"Unix Makefiles" \
			-D"CMAKE_C_FLAGS=${cmake_cflags}" \
			-D"CMAKE_CXX_FLAGS=${cmake_cflags}" \
			-D"CMAKE_EXE_LINKER_FLAGS=${cmake_cflags}" \
			${cmake_opts} \
		|| throwError INTERNAL "${target} cmake failed"
	fi

	if "${build_vm}" || "${build_engine}"
	then
		daemon_dir="$(cmake -H"${root_dir}" -B"${target_build_dir}" -LH | grep '^DAEMON_DIR:' | sed -e 's/[^=]*=//')"
	fi

	if "${build_vm}"
	then
		# build vm

		cmake --build "${target_build_dir}" -- -j"${job_count}" nacl-vms \
		|| throwError INTERNAL "${target} build failed"
	fi

	if "${build_engine}"
	then
		# build engine

		cmake --build "${target_build_dir}" -- -j"${job_count}" \
		|| throwError INTERNAL "${target} build failed"

		if "${system_windows}"
		then
			engine_file_list="${engine_file_list} $(cd "${target_build_dir}" && ls *.dll)"
		elif "${system_macos}"
		then
			# On Mac there are multiple copies of each dylib; get the ones with 3 version numbers
			# stat -f%N just echos back the filenames while erroring if one doesn't exist
			engine_file_list="${engine_file_list} $(cd "${target_build_dir}" && stat -f%N libGLEW.*.*.*.dylib libopenal.*.*.*.dylib)"
		fi
	fi

	if "${produce_symbols}"
	then
		# build breakpad

		local breakpad_dir="${daemon_dir}/libs/breakpad"
		local dumpsyms_bin="$(getBinPath ${host_windows} ${breakpad_dir}/src/tools/${dumpsyms_relpath})"

		if ! [ -d "${breakpad_dir}" ]
		then
			throwError INTERNAL "breakpad dir missing: ${breakpad_dir}"
		fi

		# Check for working dump_syms. In MSYS2 it doesn't run from an opposite-bitness shell.
		set +e
		"${dumpsyms_bin}" --help 2>/dev/null
		local exitcode=$?
		set -e

		if [ "${exitcode}" -gt 1 ]
		then
			(
				cd "${breakpad_dir}"

				autoreconf -fvi && ./configure \
				|| throwError INTERNAL 'breakpad configure failed'
			)

			make -C"${breakpad_dir}" clean \
			|| true

			local make_targets=''
			if "${host_windows}"
			then
				make_targets='src/tools/windows/dump_syms_dwarf/dump_syms.exe'
			fi
			make -j"${job_count}" -C"${breakpad_dir}" $make_targets \
			|| throwError INTERNAL 'breakpad build failed'
		fi
	fi

	if "${build_base}"
	then
		# Reuse vmpak_version_string on purpose.
		basepak_archive_filename="${release_dir}/${basepak_archive_basename}${vmpak_version_string}.${pak_archive_extension}"

		if [ -f "${basepak_archive_filename}" ]
		then
			rm -v "${basepak_archive_filename}"
		fi

		# make base package
		dpk_build_dir="${target_build_dir}"

		if "${build_vm}"
		then
			local dpk_build_dir="${target_root_dir}/dpk"

			if [ -d "${dpk_build_dir}" ]
			then
				rm -r "${dpk_build_dir}"
			fi

			mkdir -pv "${dpk_build_dir}"
		fi

		if "${fake_urcheon}"
		then
			fakeUrcheon "${dpk_build_dir}" "${basepak_archive_filename}" "${dpk_dir}"
		else
			runUrcheon "${dpk_build_dir}" "${basepak_archive_filename}" "${dpk_dir}"
		fi
	fi

	if "${build_vm}"
	then
		cleanSymbols "${symbol_dir}" "${symbol_archive_filename}"

		# extract vm symbols

		for vm in ${vm_kind_list}
		do
			for arch in ${vm_arch_list}
			do
				(
					cd "${target_build_dir}"

					local vm_file="${vm}-${arch}.nexe"
					local stripped_vm_file="${vm}-${arch}-stripped.nexe"

					printf 'extracting symbols from %s\n' "${vm_file}"

					if ! [ -f "${vm_file}" ]
					then
						throwError INTERNAL "missing: ${vm_file}"
					fi

					if [ -f "${main_nexe}" ]
					then
						rm "${main_nexe}"
					fi

					ln -s "${vm_file}" 'main.nexe'

					dumpSymbols "${dumpsyms_bin}" "${symbol_dir}" "${main_nexe}"

					mkdir -pv "${content_dir}"

					cp -v "${stripped_vm_file}" "${content_dir}/${vm_file}"
				)
			done
		done

		# compress vm symbols

		package "${symbol_archive_format}" "${symbol_archive_filename}" "${symbol_dir}"

		cp -v "${symbol_archive_filename}" "${content_dir}/${symbol_archive_basename}.${symbol_archive_format}"

		# make vm package

		if "${build_base}"
		then
			vmpak_archive_filename="${basepak_archive_filename}"

			package --extend "${pak_archive_format}" "${vmpak_archive_filename}" "${content_dir}"
		else
			vmpak_archive_filename="${release_dir}/${vmpak_archive_basename}${vmpak_version_string}.${pak_archive_extension}"

			package "${pak_archive_format}" "${vmpak_archive_filename}" "${content_dir}"
		fi

		cleanSymbols "${symbol_dir}" "${symbol_archive_filename}"
		cleanVmBuildDir "${content_dir}" "${symbol_archive_basename}"
	fi

	if "${build_engine}"
	then
		local bin_path
		local engine_bin_path

		cleanSymbols "${symbol_dir}" "${symbol_archive_filename}"

		mkdir -pv "${content_dir}"

		if "${produce_symbols}"
		then
			# extract engine symbols

			for bin in ${engine_symbolize_list}
			do
				bin_path="${target_build_dir}/${bin}"
				printf 'extracting symbols from %s\n' "${bin_path}"
				dumpSymbols "${dumpsyms_bin}" "${symbol_dir}" "${bin_path}"
			done
		fi

		local engine_file_dest="${content_dir}"
		if "${system_macos}"
		then
			engine_file_dest="${content_dir}/Unvanquished.app/Contents/MacOS"
			mkdir -pv "${engine_file_dest}"
			cp -v "${root_dir}/macosx/unvanquished.sh" "${engine_file_dest}"
			cp -av "${target_build_dir}/SDL2.framework" "${engine_file_dest}"
			rm -rv "${engine_file_dest}/SDL2.framework/Headers"
			rm -rv "${engine_file_dest}/SDL2.framework/Versions/A/Headers"
			rm -rv "${engine_file_dest}/SDL2.framework/Versions/Current/Headers"
			cp -v "${root_dir}/macosx/Info.plist" "${content_dir}/Unvanquished.app/Contents"
			mkdir -v "${content_dir}/Unvanquished.app/Contents/Resources"
			cp -v "${root_dir}/macosx/Unvanquished.icns" "${content_dir}/Unvanquished.app/Contents/Resources"
		fi

		for file in ${engine_file_list}
		do
			cp -v "${target_build_dir}/${file}" "${engine_file_dest}/${file}"
		done

		for file in ${engine_strip_list}
		do
			echo "Stripping ${file}"
			"${strip}" "${engine_file_dest}/${file}"
		done

		if "${produce_symbols}"
		then
			# compress engine symbols

			package "${symbol_archive_format}" "${symbol_archive_filename}" "${symbol_dir}"

			cp -v "${symbol_archive_filename}" "${content_dir}/${symbol_archive_basename}-${target}.${symbol_archive_format}"
		fi

		# make engine archive

		engine_archive_filename="${release_dir}/${engine_archive_basename}${engine_version_string}.${engine_archive_format}"

		package "${engine_archive_format}" "${engine_archive_filename}" "${content_dir}"

		cleanSymbols "${symbol_dir}" "${symbol_archive_filename}"
		cleanEngineBuildDir "${content_dir}"
	fi
}

root_dir="$(git rev-parse --show-toplevel)"

[ -f "${root_dir}/src/cgame/cg_main.cpp" ] || throwError INTERNAL "must be called from game source tree"

[ -z "${1:-}" ] && throwError BADREQUEST 'missing target'

job_count=''
parallel_target='false'
write_version_string='false'
write_username_string='false'
target_list=''
needs_urcheon='false'
fake_urcheon='false'
old_reference=''
vmpak_name=''
basepak_name=''

while [ -n "${1:-}" ]
do
	case "${1}" in
		'base'|'mod')
			target_list="${target_list} ${1}"
			needs_urcheon='true'
			shift
			;;
		'vm'|'linux-amd64'|'linux-i686'|'macos-amd64'|'windows-amd64'|'windows-i686')
			target_list="${target_list} ${1}"
			shift
			;;
		'macos-i686')
			throwError NOTIMPLEMENTED "unsupported target: ${1}"
			;;
		'-d')
			shell_options+=(-x)
			shift
			;;
		'-j'*)
			job_count="${1:2}"
			shift
			;;
		'-p')
			parallel_target='true'
			shift
			;;
		'-u')
			write_username_string='true'
			shift
			;;
		'-v')
			write_version_string='true'
			shift
			;;
		'--fake-urcheon')
			fake_urcheon='true'
			shift
			;;
		'-r'|'--reference')
			shift

			if [ -z "${1:-}" ]
			then
				throwError BADREQUEST "missing old git reference"
			fi

			old_reference="${1}"
			shift
			;;
		'--vmpak-name')
			shift

			if [ -z "${1:-}" ]
			then
				throwError BADREQUEST "missing vm pak name"
			fi

			vmpak_name="${1}"
			shift
			;;
		'--basepak-name')
			shift

			if [ -z "${1:-}" ]
			then
				throwError BADREQUEST "missing base pak name"
			fi

			basepak_name="${1}"
			shift
			;;
		'-h'|'--help')
			printHelp
			;;
		'-'*)
			throwError BADREQUEST "unknown option: ${1}"
			;;
		*)
			throwError BADREQUEST "unknown target: ${1}"
			;;
	esac
done

if "${needs_urcheon}"
then
	if "${fake_urcheon}"
	then
		printWarning 'Forcing the bad emulation of Urcheon.'
	else
		if ! command -v 'urcheon' >/dev/null
		then
			throwError INTERNAL 'Urcheon not found, you can use --fake-urcheon as a workaround, file optimizations and delta pak feature are missing.'
			fake_urcheon='false'
		fi
	fi

	if "${fake_urcheon}"
	then
		if [ -n "${old_reference}" ]
		then
			throwError BADREQUEST 'Delta pak feature with --reference is only supported with Urcheon.'
		fi
	fi
fi

for target in ${target_list}
do
	if "${parallel_target}"
	then
		build "${job_count}" "${write_version_string}" "${write_username_string}" "${root_dir}" "${target}" &
	else
		build "${job_count}" "${write_version_string}" "${write_username_string}" "${root_dir}" "${target}"
	fi
done
wait

#EOF
